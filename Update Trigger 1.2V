//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☣☢
//☠☠☠☠☠☠☠☠Librerias☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
#include <Arduino_FreeRTOS.h>
#include <LiquidCrystal_I2C.h>
#include<Wire.h>
#include <EEPROM.h>
#include <SPI.h>
#include <SD.h>


//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠DefiniciondePines☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠Botones☠☠☠☠☠☠☠☠☠☠
#define BotonArriba    18    //Entrada para el boton de aumento de tiempo Color=Rojo
#define BotonAbajo     19    //Entrada para el boton de decremento de tiempo Color=Azul
#define BotonPause     20
#define BotonReiniciar 21 
//☠☠☠☠☠☠☠Realy☠☠☠☠☠☠☠☠☠☠
#define pinRelay A2           // Salida del Relay
//☠☠☠☠☠☠☠Sensor☠☠☠☠☠☠☠☠☠
#define Sensor 7              //Pin del Senso
//☠☠☠☠☠☠☠LCD I2C☠☠☠☠☠☠☠☠☠
#define SCL SCL
#define SDA SDA
LiquidCrystal_I2C lcd(0x27,20,4);  // set the LCD address to 0x27 for a 16 chars and 2 line display or 0x3F

//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠Variables☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
long diferencia = 0;
long tiempo_anterior = 0;
unsigned int cycles = 0;   // Variable que guarda los ciclos (dando un rango útil de 0 a 65,535 ciclos)
int timer;                 //Tiempo que mostrara la pantalla LCD
int tiempoTemp = 60;       //Valor del temporizador del timer predeterminado
int highCiclos;            //Variable para guardar datos altos de los ciclos en la EEPROM
int lowCiclos;             //Variable para guardar datos bajos de los ciclos en la EEPROM
int tiempoHigh;            //variable de tiempo en alto que se guarda en la EEPROM
int tiempoLow;             //variable de tiempo en bajo que se guarda en la EEPROM
int rebotes;               //variable que permite que en los botone al mantener presionados capture un solo pulso   
int resetTemp = 5;         //

int resetTimer;
int BotonPauseVar = 0;
bool actualizar;
bool indicadorPause;
bool EstadoPuerta = true;  //Estado de la puerta
bool Posicion;

enum ESTADO_PUERTA{
     Puerta_Abierta,
     Puerta_Cerrada
   };


//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠Tasks☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
TaskHandle_t relay_Handle, sensor_Handle, botonArriba_Handle, botonAbajo_Handle, botonPause_Handle, botonReiniciar_Handle, timer_Handle;


//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠CallbackTasks☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
ISR(TIMER1_OVF_vect) {
  TCNT1 = 2791;               //valor para 1 segundo
  actualizar = true;
  if(resetTimer == true){
    resetTemp--;
    }
}

void reinicio() {
  timer = tiempoTemp;
}

void actualizarLCD() {
  lcd.clear();
  lcd.setCursor(6, 0);
  lcd.print("#Cycles");
  lcd.setCursor(6, 1);
  lcd.print(cycles);
  lcd.setCursor(6, 2);
  lcd.print("Timer");
  lcd.setCursor(6, 3);
  lcd.print(tiempoTemp);
}

void Relay_Task(void *pvParameters){
  pinMode(pinRelay, OUTPUT);
  while(1){
    digitalWrite(pinRelay, LOW);
    vTaskDelay(300);
    digitalWrite(pinRelay, HIGH);
    vTaskDelay(300);
  }
}

void Sensor_Task(void *pvParameters){
  pinMode(Sensor, INPUT);
  while(1){
    Posicion = digitalRead(Sensor);
    if(Posicion == Puerta_Abierta){
      cycles++;
      EstadoPuerta = true;
    }else{
      EstadoPuerta = false;
    }
  }
}
//
//void Timer_Task(void *pvParameters){
//      if(indicadorPause == false){
//        if(actualizar == true){
//          timer = timer - 1;
//    
//          if(timer == 0 ){
//            vTaskResume(relay_Handle);
//            reinicio();
//          }else{
//            vTaskSuspend(relay_Handle);
//          }
//          
//          lcd.clear();
//          actualizar = false;
//          vTaskResume(sensor_Handle);
//          vTaskSuspend(botonPause_Handle);    
//          }
//          //grabar en la eeprom el conteo de cycle
//         EEPROM.write(0, cycles >> 8);
//         EEPROM.write(1, cycles & 0xFF);
//        }    
//  }

void Boton_Reiniciar_Task(void *pvParameters){
  pinMode(BotonReiniciar, INPUT_PULLUP);
  while(1){
       diferencia = millis() - tiempo_anterior;
       tiempo_anterior = millis();
        if (diferencia > 250){
            resetTimer= true;
              //Reiniciar una prueba
              if(resetTemp < 0){
                resetTemp = 5;
                cycles = 0;
                BotonPauseVar = 2;
                //indicadorPause = false;
                timer = tiempoTemp;
                EEPROM.write(0, 0);
                EEPROM.write(1, 0);
                lcd.clear();
              }
            }
          timer = tiempoTemp;
          actualizarLCD();
          vTaskDelay(300);
        }
  }

void Boton_Arriba_Task(void *pvParameters){
  pinMode(BotonArriba, INPUT_PULLUP);
  while(1){
       diferencia = millis() - tiempo_anterior;
       tiempo_anterior = millis();
        if (diferencia > 250){
          tiempoTemp = tiempoTemp + 10;
            if (tiempoTemp > 600) {
              tiempoTemp = 10;
            }
          timer = tiempoTemp;
          actualizarLCD();
          vTaskDelay(300);
        }
  }
}

void Boton_Abajo_Task(void *pvParameters){
  pinMode(BotonAbajo, INPUT_PULLUP);
  while(1){
       diferencia = millis() - tiempo_anterior;
       tiempo_anterior = millis();
       if (diferencia > 250){
        tiempoTemp = tiempoTemp - 10;
          if (tiempoTemp < 10) {
            tiempoTemp = 600;
        }
        timer = tiempoTemp;
        actualizarLCD();
        vTaskDelay(300);
       }
  }
}

void Boton_Pause_Task(void *pvParameters){
  pinMode(BotonPause, INPUT_PULLUP);
  while(1){
    diferencia = millis() - tiempo_anterior;
    tiempo_anterior = millis();
    if(diferencia > 250){
      actualizarLCD();
      BotonPauseVar = BotonPauseVar + 1;
      if (BotonPauseVar == 1) {
        indicadorPause = true;
        vTaskSuspend(timer_Handle);
      }
      else {
        indicadorPause = false;
        vTaskResume(timer_Handle);
      }
  
      while (BotonPauseVar == 1) {
      if (digitalRead(BotonPause) == HIGH) {
        BotonPauseVar = BotonPauseVar + 1;         
        vTaskResume(botonReiniciar_Handle);          
      }else{
        resetTimer= false;
        resetTemp=5;
        vTaskSuspend(botonReiniciar_Handle);
      }
          
      if (BotonPauseVar == 2) {
          EEPROM.write(2, tiempoTemp >> 8);
          EEPROM.write(3, tiempoTemp  & 0xFF);
          BotonPauseVar = 0;
          //guardar en la eeprom el timer
          indicadorPause = false;
          lcd.clear();
          }
        }
     }else{
        vTaskSuspend(botonArriba_Handle);
        vTaskSuspend(botonAbajo_Handle);
    }
 
  }
}

//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠SetUp☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  lcd.init();
  lcd.backlight();
  lcd.clear();

  timer = tiempoTemp;
  TCCR1A = 0;               //1A y 1B variables para iniciar y declarar TCNT1
  TCCR1B = 0;
  TCNT1 = 2791;             // valor para 1 segundo
  TCCR1B |= (1 << CS12);    // 256 prescaler
  TIMSK1 |= (1 << TOIE1);   // enable timer overflow interrupt

  //Leer el cycles y el contador desde la EEPROM
  highCiclos = EEPROM.read(0);
  lowCiclos = EEPROM.read(1);

  tiempoHigh = EEPROM.read(2);
  tiempoLow = EEPROM.read(3);

  cycles = highCiclos;
  cycles = cycles << 8;
  cycles |= lowCiclos;

  tiempoTemp = tiempoHigh;
  tiempoTemp = tiempoTemp << 8;
  tiempoTemp |= tiempoLow;
  timer = tiempoTemp;
  
  //Task de las Entradas del Trigger
  xTaskCreate(Relay_Task, "Task del Relay", 100, NULL, 1, &relay_Handle);
  xTaskCreate(Sensor_Task, "Task del Sensor", 100, NULL, 1, &sensor_Handle);  
  xTaskCreate(Boton_Arriba_Task, "Task de aumentar tiempo", 100, NULL, 1, &botonArriba_Handle);
  xTaskCreate(Boton_Abajo_Task, "Task de disminuir tiempo", 100, NULL, 1, &botonAbajo_Handle);
  xTaskCreate(Boton_Pause_Task, "Task de pausar", 100, NULL, 1, &botonPause_Handle);
  xTaskCreate(Boton_Reiniciar_Task, "Task de reiniciar prueba", 100, NULL, 1, &botonReiniciar_Handle);
//  xTaskCreate(Timer_Task, "Task tiempo", 100, NULL, 1, &timer_Handle);

  
  attachInterrupt(digitalPinToInterrupt(BotonArriba),Boton_Arriba_Task, FALLING);
  attachInterrupt(digitalPinToInterrupt(BotonAbajo),Boton_Abajo_Task, FALLING);
  attachInterrupt(digitalPinToInterrupt(BotonPause), Boton_Pause_Task, FALLING);
  attachInterrupt(digitalPinToInterrupt(BotonPause), Boton_Reiniciar_Task, FALLING);
}

void loop() {
       if(indicadorPause == false){
        if(actualizar == true){
          timer = timer - 1;
    
          if(timer == 0 ){
            vTaskResume(relay_Handle);
            reinicio();
          }else{
            vTaskSuspend(relay_Handle);
          }
          
          lcd.clear();
          actualizar = false;
          vTaskResume(sensor_Handle);
          vTaskSuspend(botonPause_Handle);    
          }
          //grabar en la eeprom el conteo de cycle
         EEPROM.write(0, cycles >> 8);
         EEPROM.write(1, cycles & 0xFF);
        } 
        lcd.setCursor(6, 0);
        lcd.print("#Cycles");
        lcd.setCursor(6, 1);
        lcd.print(cycles);
        lcd.setCursor(6, 2);
        lcd.print("Timer");
        lcd.setCursor(6, 3);
        lcd.print(timer);
  }

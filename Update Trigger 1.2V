//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☣☢
//☠☠☠☠☠☠☠☠Librerias☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
#include <Arduino_FreeRTOS.h>
#include <LiquidCrystal_I2C.h>
#include<Wire.h>
#include <EEPROM.h>
#include <SPI.h>
#include <SD.h>

// fecha 18/04/22

//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠DefiniciondePines☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠Botones☠☠☠☠☠☠☠☠☠☠
#define BotonArriba A0     //Entrada para el boton de aumento de tiempo Color=Rojo
#define BotonAbajo 12      //Entrada para el boton de decremento de tiempo Color=Azul
#define BotonPause 8       //Boton Puase Color = Verde
//☠☠☠☠☠☠☠Realy☠☠☠☠☠☠☠☠☠☠
#define pinRelay A2        // Salida del Relay
//☠☠☠☠☠☠☠Sensor☠☠☠☠☠☠☠☠☠
#define Sensor = 7;        //Pin del Sensor
//☠☠☠☠☠☠☠LCD I2C☠☠☠☠☠☠☠☠☠
#define SCL A5
#define SDA A4
LiquidCrystal_I2C lcd(0x27,20,4);  // set the LCD address to 0x27 for a 16 chars and 2 line display or 0x3F

//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠Variables☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
unsigned int cycles = 0;   // Variable que guarda los ciclos (dando un rango útil de 0 a 65,535 ciclos)
int timer;                 //Tiempo que mostrara la pantalla LCD
int tiempoTemp = 60;       //Valor del temporizador del timer predeterminado
int highCiclos;            //Variable para guardar datos altos de los ciclos en la EEPROM
int lowCiclos;             //Variable para guardar datos bajos de los ciclos en la EEPROM
int tiempoHigh;            //variable de tiempo en alto que se guarda en la EEPROM
int tiempoLow;             //variable de tiempo en bajo que se guarda en la EEPROM
int rebotes;               //variable que permite que en los botone al mantener presionados capture un solo pulso   
int resetTemp = 5;         //

int resetTimer;
int BotonPauseVar = 0;
bool actualizar;
bool indicadorPause;
bool EstadoPuerta = true;  //Estado de la puerta

const enum ESTADO_PUERTA{
     Puerta_Abierta,       //Valor 0
     Puerta_Cerrada        //Valor 1
   };


//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠Tasks☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
TaskHandle_t relay_Handle, sensor_Handle, botonArriba_Handle, botonAbajo_Handle, botonPause_Handle;


//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠SetUp☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  lcd.init();
  lcd.backlight();
  lcd.clear();

  timer = tiempoTemp;
  TCCR1A = 0;               //1A y 1B variables para iniciar y declarar TCNT1
  TCCR1B = 0;
  TCNT1 = 2791;             // valor para 1 segundo
  TCCR1B |= (1 << CS12);    // 256 prescaler
  TIMSK1 |= (1 << TOIE1);   // enable timer overflow interrupt

  //Leer el cycles y el contador desde la EEPROM
  highCiclos = EEPROM.read(0);
  lowCiclos = EEPROM.read(1);

  tiempoHigh = EEPROM.read(2);
  tiempoLow = EEPROM.read(3);

  cycles = highCiclos;
  cycles = cycles << 8;
  cycles |= lowCiclos;

  tiempoTemp = tiempoHigh;
  tiempoTemp = tiempoTemp << 8;
  tiempoTemp |= tiempoLow;
  timer = tiempoTemp;
  
  //Task de las Entradas del Trigger
  xTaskCreate(Realy_Task, "Task del Relay", 100, NULL, 1, &relay_Handle);
  xTaskCreate(Sensor_Task, "Task del Sensor", 100, NULL, 1, &sensor_Handle);  
  xTaskCreate(Boton_Arriba_Task, "Task de aumentar tiempo", 100, NULL, 1, &botonArriba_Handle);
  xTaskCreate(Boton_Abajo_Task, "Task de disminuir tiempo", 100, NULL, 1, &botonAbajo_Handle);
  xTaskCreate(Boton_Pause_Task, "Task de pausar", 100, NULL, 1, &botonPause_Handle);
  xTaskCreate(Timer_Task, "Task del tiempo", 100, NULL, 2, NULL);

  
  attachInterrupt(digitalPinToInterrupt(BotonArriba),Boton_Arriba_Task, FALLING);
  attachInterrupt(digitalPinToInterrupt(BotonAbajo),Boton_Abajo_Task, FALLING);
  attachInterrupt(digitalPinToInterrupt(BotonPause), Boton_Pause_Task, FALLING);
}



//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
//☠☠☠☠☠☠☠CallbackTasks☠☠☠☠☠☠
//☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠
void Timer_Task(void *pvParameters){
  if(){
    vTaskResume(botonPause_Handle);
  }
  else{
      if(indicadorPause == false){
        if(actualizar == true){
          timer = timer - 1;
    
          if(timer == 0 ){
            vTaskResume(relay_Handle);
            reinicio();
          }else{
            vTaskSuspend(relay_Handle);
          }
          
          lcd.clear();
          actualizar = false;
          Sensor_Task();    
          }
        }
    
      lcd.setCursor(6, 0);
      lcd.print("#Cycles");
      lcd.setCursor(6, 1);
      lcd.print(cycles);
      lcd.setCursor(6, 2);
      lcd.print("Timer");
      lcd.setCursor(6, 3);
      lcd.print(timer);
  }
}




void Boton_Pause_Task(void *pvParameters){
  pinMode(BotonPause, INPUT);
  while(1){
    if(){
      actualizarLCD();
      BotonPauseVar = BotonPauseVar + 1;
      if (BotonPauseVar == 1) {
        indicadorPause = true;
      }
      else {
        indicadorPause = false;
      }
  
      while (BotonPauseVar == 1) {
          vTaskResume(Boton_Arriba_Task);
          vTaskResume(Boton_Abajo_Task);
          if (digitalRead(BotonPause) == LOW) {
            if(bitRead(rebotes, 1) == 0){
              BotonPauseVar = BotonPauseVar + 1;
              }else{          
                resetTimer= true;
                if (resetTemp< 0){
                  resetTemp = 5;
                  cycles = 0;
                  BotonPauseVar = 2;
                  //indicadorPause = false;
                  timer = tiempoTemp;
                  EEPROM.write(0, 0);
                  EEPROM.write(1, 0);
                  lcd.clear();                
                  }
                }    
             }else{
            resetTimer= false;
            resetTemp=5;
          }    
              
          if(BotonPauseVar == 2){
            EEPROM.write(2, tiempoTemp >> 8);
            EEPROM.write(3, tiempoTemp  & 0xFF);
            BotonPauseVar = 0;
            //guardar en la eeprom el timer
            indicadorPause = false;
            lcd.clear();
       }
      }
     }else{
      vTaskSuspend(Boton_Arriba_Task);
      vTaskSuspend(Boton_Abajo_Task);
      vTaskSuspend(Boton_Arriba_Task);
    }
 
  }
}


void Boton_Arriba_Task(void *pvParameters){
  pinMode(BotonArriba, INPUT);
  while(1){
        tiempoTemp = tiempoTemp + 10;
        if (tiempoTemp > 600) {
          tiempoTemp = 10;
        }
        timer = tiempoTemp;
        actualizarLCD();
        vTaskDelay(300);
  }
}

void Boton_Abajo_Task(void *pvParameters){
  pinMode(BotonAbajo, INPUT);
  while(1){
        tiempoTemp = tiempoTemp - 10;
        if (tiempoTemp < 10) {
          tiempoTemp = 600;
        }
        timer = tiempoTemp;
        actualizarLCD();
        vTaskDelay(300);
  }
}

void Realy_Task(void *pvParameters){
  pinMode(pinRelay, OUTPUT);
  while(1){
    digitalWrite(pinRelay, LOW);
    vTaskDelay(500);
    digitalWrite(pinRelay, HIGH);   
  }
 
}

void Sensor_Task(void *pvParameters){
  pinMode(Sensor, INPUT);
  while(1){
      bool Entrada_Sensor = digitalRead(Sensor);
      //false = abierto, true = cerrado
      if(Entrada_Sensor == Puerta_Abierta){
        //Agregar Posicion de la Puerta Abierta en la LCD
        cycles++;
      }else if(Entrada_Sensor == Puerta_Cerrada){                                  
        //Agregar Posicion de la Puerta Cerrada en la LCD               
      }
      EEPROM.write(0, cycles >> 8);
      EEPROM.write(1, cycles & 0xFF);
      vTaskDelay(300);
  }
}




void loop() {}
